#lang ivy1.5

type node
type list
type val

relation head(H:node,L:list)	#if H is head in L
relation tail(T:node,L:list)	#if T is tail in L
relation inList(N:node,L:list)  #if N is in L
relation next(N1:node,N2:node)	#if N1.next is N2 
relation empty(L:list)	#if list is empty

init empty(L) & ~head(H,L) & ~tail(T,L) & ~inList(N,L) & ~next(N1,N2)#all lists are empty and has no tails and no heads


action push(n:node , l:list) = {
	assume ~inList(n,l);
	if empty(l) { #note to self last line before "}" should be without ";"
		assert ~tail(X,l) & ~head(X,l);

		#if the list is empty set "n" to be the head and tail of the list "l"

		tail(n,l):=true;
		empty(l):=false;
		head(n,l):=true
		
	} else {

		assert tail(X,l) & head(X,l);
		#the list is not empty set "n" to be the head and the previous head "x" to be "n.next" 	

		if some x:node. head(x,l) { #note to self last line before "}" should be without ";"
			next(n,x):=true;
			head(x,l):=false;
			head(n,l):=true;
			assert(next(n,x))
		}
	};	
	inList(n,l):=true;
	assert head(n,l) & exists X. tail(X,l)



	
}

action pop(l:list) returns(n:node) = {
		assume ~empty(l);
		assume inList(n,l);
		if some x:node. tail(x,l) {
			n:=x;

			#find "l's" tail then change its previous to be the new tail if doesnt exist set list to empty 

			if some y:node. next(y,x) & inList(y,l){	#note to self last line before "}" should be without ";"
				tail(x,l):=false;
				tail(y,l):=true
			}else{ #note to self last line before "}" should be without ";"
				empty(l):=true;
				tail(x,l):=false;
				head(x,l):=false
			};
			inList(x,l):=false
		};
		assert tail(X,l)|empty(l)
}

action test = {
  assert ~(X ~= Z & head(X,L) & head(Z,L)); #no 2 heads
  assert ~(X ~= Z & tail(X,L) & tail(Z,L)); #no 2 tails
  assert ~(empty(L) & head(X,L)); #no empty with head
  assert ~(head(X,L)& ~inList(X,L));#no head not in list
  assert ~(tail(X,L)& ~inList(X,L))#no tail not in list 
}

export test
export push
export pop


conjecture ~(head(N,L) & empty(L)) #empty list has no head
conjecture ~(tail(N,L) & empty(L)) #empty list has no tail
conjecture empty(L) -> ~head(N,L)
conjecture empty(L) -> ~tail(N,L)

conjecture ~empty(L) -> exists N. head(N,L)
conjecture ~empty(L) -> exists N. tail(N,L)



conjecture ~(next(N,N)) # node cant be its own next
conjecture ~(head(N,L) & head(P,L) & N ~= P) #no 2 heads
conjecture ~(tail(N,L) & tail(P,L) & N ~= P) #no 2 tails

conjecture ~(head(N,L) & ~inList(N,L)) # head must be in list
conjecture ~(tail(N,L) & ~inList(N,L)) # tail must be in list

conjecture (inList(N1,L) & inList(N2,L) & N1~=N2 & tail(N1,L)) -> exists X. inList(X,L) & next(X,N1) # if a list contains at least 2 nodes, 1 element must have tail node, as its next

conjecture head(N,L) -> inList (N,L)
conjecture tail(N,L) -> inList (N,L)

