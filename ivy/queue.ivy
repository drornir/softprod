#lang ivy1.5

type node
type state

relation reach (N1:node, N2:node)# if N2 is reachable from N1
individual sentinel:node
individual head:node
individual tail:node
individual empty:node

individual a:node
individual b:node
individual q1:state
individual q2:state
individual qe:state
individual qc:state #current state
axiom q1~=q2
axiom q2~=qe
axiom q1~=qe
axiom Q = q1 | Q = q2 | Q = qe
init reach(N1,N2) <-> N1=N2#all lists are empty and has no tails and no heads
init sentinel=head & head=tail & empty~=head
init qc = q1

action q1_action = {
    assume qc = q1;
    local x: node{
        if * {
            call push(x);
            if x = a {
                qc := q2
            }
        }
        else {
            call x := pop();
            if x = a {
                qc := qe
            }
        }
    }

}
#conjecture after we write all state actions: qc ~=qe

action push(n:node) = {
    assume n~= empty;
    assume ~reach(head,n);
    reach(X,Y):= reach(X,Y) | (reach(X,tail) & Y=n);
    tail:=n
}

action pop() returns(n:node) = {
    if (head=tail) {
        n:=empty
    }
    else {
        assume reach(head,n) & ((reach(X,n) ->(n=X | X=head))) & n~=head;

        reach(X,Y):= (reach(X,Y) & Y~=n & X~=n) | X=Y;
        if (reach(head,X) -> head=X) {
            tail:=head
        }
    }
}
action test = {
}
export test
export push
export pop


conjecture reach(X,X)
conjecture (reach(X,Y) & reach(Y,Z)) -> reach(X,Z)
conjecture reach(X,Y) & reach(Y,X) -> X=Y
conjecture reach(X,Y) & reach(X,Z) -> reach(Y,Z) | reach(Z,Y)
conjecture reach(head,tail)
conjecture (forall X. reach(head,X) -> (head=X)) -> head=tail
