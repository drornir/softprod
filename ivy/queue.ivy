#lang ivy1.5

type node
type state

relation reach (N1:node, N2:node)# if N2 is reachable from N1
relation nondet
individual sentinel:node
individual head:node
individual tail:node
individual empty:node

individual a:node
individual b:node
individual q1:state # a,b outside of queue
individual q2:state # a inside, b outside
individual q3:state # both a,b are inside
individual q4:state # a outsde, b inside
individual qe:state
individual qc:state #current state

axiom q1~=qe

axiom q2~=q1
axiom q2~=qe

axiom q3~=q1
axiom q3~=q2
axiom q3~=qe

axiom q4~=q1
axiom q4~=q2
axiom q4~=q3
axiom q4~=qe

axiom Q = q1 | Q = q2 | Q = qe | Q=q3 | Q=q4

axiom a~=b
axiom a~=empty
axiom b~=empty
axiom a~= sentinel
axiom b~= sentinel
axiom empty~= sentinel

init reach(N1,N2) <-> N1=N2#all lists are empty and has no tails and no heads
init sentinel=head & head=tail & empty~=head
init qc = q1

action q1_action = {
    assume qc = q1;
    local x: node{
		nondet:=*;
        if nondet {
			assume x~=empty;
			assume x~= b;
            call push(x);
            if x = a {
                qc := q2
            }
        }
        else {
            call x := pop();
            if x = a {
                qc := qe
            }
        }
    }

}

action q2_action = {
	assume qc = q2;
	local x:node {
		assume x~=a;
		nondet:=*;
		if nondet {
			assume x~=empty;
			call push(x);
			if x = b {
				qc:=q3
			}

		}
		else {
			call x:=pop();
			if x= b {
				qc:=qe
			};
			if x= a {
				qc:= q1
			}
		}
	}
}

action q3_action = {
	assume qc=q3;
	local x:node {
		assume x~= a & x~=b;
		nondet:=*;
		if nondet {
			assume x~=empty;
			call push(x)
		}
		else {
			call x:=pop();
			if x=b {
			 qc:=qe
			};
			if x=empty {
				qc:=qe
			};
			if x= a {
				qc:=q4
			}
		}
	}
}

action q4_action = {
	assume qc=q4;
	local x:node {
		assume x~=a & x~=b;
		nondet:=*;
		if nondet {
			assume x~=empty;
			call push(x)
		}
		else {
			call x:=pop();
			if x=b {
				qc:=q1
			};
			if x=a {
				qc:=qe
			};
			if x=empty {
				qc:=qe
			}
		}
	}
}


action push(n:node) = {
    assume n~= empty;
    assume ~reach(head,n);
	assume reach(n,X) -> X=n;
    reach(X,Y):= reach(X,Y) | (reach(X,tail) & Y=n);
    tail:=n
}

action pop returns(n:node) = {
    if (head=tail) {
        n:=empty
    }
    else {
        assume reach(head,n) & ((reach(X,n) ->(n=X | X=head))) & n~=head;
        reach(X,Y):= (reach(X,Y) & Y~=n & X~=n) | X=Y;
		
        if (reach(head,X) -> head=X) {
            tail:=head
        }
    }
}
action test = {
}
#export test
#export push
#export pop
export q1_action
export q2_action
export q3_action
export q4_action


conjecture reach(X,X)
conjecture (reach(X,Y) & reach(Y,Z)) -> reach(X,Z)
conjecture reach(X,Y) & reach(Y,X) -> X=Y
conjecture reach(X,Y) & reach(X,Z) -> reach(Y,Z) | reach(Z,Y)
conjecture reach(head,tail)
conjecture (forall X. reach(head,X) -> (head=X)) -> head=tail
conjecture reach(tail,X) -> X=tail
conjecture qc ~= qe
conjecture empty ~=head & empty ~=sentinel & empty ~= tail
conjecture qc=q1 -> (reach(X,a) | reach(a,X)) -> (X=a & a~=head & a~=tail)
conjecture qc=q1 -> ~reach(b,tail)
conjecture head=tail -> head = sentinel
conjecture qc =q2 -> reach(a,tail)
conjecture qc =q2 -> ~reach(b,tail)
conjecture sentinel = head
conjecture head=tail -> ( reach(X,tail) -> X = tail )
conjecture (reach(X,Y) & X~=Y) -> reach(X,tail)# if a node is connected, it must be in the queue
conjecture qc=q3 -> (reach(a,tail) & reach (b,tail) & reach (a,b))
conjecture reach(X,tail) -> reach(head,X)
conjecture (reach (X,empty) | reach (empty, X)) -> X= empty

conjecture qc=q4 ->~reach (a,tail)
conjecture qc=q4-> reach(b,tail)

