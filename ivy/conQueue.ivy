#lang ivy1.5

# no longer based on this implementation: https://www.cs.rochester.edu/research/synchronization/pseudocode/queues.html

type node
type state
type thread
type line

relation reach (N1:node, N2:node)# if N2 is reachable from N1
relation nondet
relation inLine (T:thread, L:line) # each thread currently in l0 or some line in the dequeue or enqueue
relation used (N:node) #in order to simulate 'new' node being created

#enq vars
relation threadEnqLast (T:thread,N:node)# local variable of last in thread t
relation threadEnqNode(T:thread, N:node) # the node thread T is trying to enqueue
relation threadEnqNext(T:thread, N:node) # the node which is "next" in line 6 in enqueue
#deq vars
relation threadDeqHead(T:thread, N:node)#the head in deq
relation threadDeqLast(T:thread, N:node)#the tail in deq
relation threadDeqNext(T:thread, N:node)#next
relation threadDeqReturnNode(T:thread, N:node)#rv

relation head(N:node)
relation tail(N:node)


individual l0:line #starting line

individual e0:line # first line in enqeue
individual e1:line # first line in enqeue loop
individual e2:line # set "next"
individual e3:line # first compare
individual e4:line # second compare and CAS if needed
individual e5:line # last line in enqeue

individual d0:line #first line in dequeue
individual d1:line #first line in dequeue
individual d2:line #first line in dequeue
individual d3:line #first line in dequeue
individual d4:line #first line in dequeue
individual d5:line #first line in dequeue

individual initNode:node
individual nullNode:node

axion initNode ~=nullNode


#line 0 different from all else
axiom l0 ~= e0
axiom l0 ~= e1
axiom l0 ~= e2
axiom l0 ~= e3
axiom l0 ~= e4
axiom l0 ~= e5
axiom l0 ~= d0

#enqueue lines different
axiom e0~=e1
axiom e0~=e2
axiom e0~=e3
axiom e0~=e4
axiom e0~=e5
axiom e0~=d0
axiom e0~=d1
axiom e0~=d2
axiom e0~=d3
axiom e0~=d4

axiom e1~=e2
axiom e1~=e3
axiom e1~=e4
axiom e1~=e5
axiom e1~=d0
axiom e1~=d1
axiom e1~=d2
axiom e1~=d3
axiom e1~=d4

axiom e2~=e3
axiom e2~=e4
axiom e2~=e5
axiom e2~=d0
axiom e2~=d1
axiom e2~=d2
axiom e2~=d3
axiom e2~=d4

axiom e3~=e4
axiom e3~=e5
axiom e3~=d0
axiom e3~=d1
axiom e3~=d2
axiom e3~=d3
axiom e3~=d4

axiom e4~=e5
axiom e4~=d0
axiom e4~=d1
axiom e4~=d2
axiom e4~=d3
axiom e4~=d4

axiom e5~=d0
axiom e5~=d1
axiom e5~=d2
axiom e5~=d3
axiom e5~=d4

axiom d0~=d1
axiom d0~=d2
axiom d0~=d3
axiom d0~=d4

axiom d1~=d2
axiom d1~=d3
axiom d1~=d4

axiom d2~=d3
axiom d2~=d4

axiom d3~=d4




init inLine(T,l0) & (inLine (T,L) -> L=l0)
init head(N) -> N=initNode
init tail(N) -> N=initNode
init used(initNode & used(nullNode)
init ~threadEnqNode(T,N)
init ~threadTail(T,N)
init ~threadEnqNext(T,N)


action l0_action(t:thread) = { #decide on an action (enqueue or dequeue)
	assume inLine (t,l0);
	inLine(t,l0) := false;
	nondet :=*;
	if nondet {
		inLine(t,d0) := true
	}
	else {
		inLine (t,e0) := true
	}

}

action e0_action (t:thread,n:node)= { #simulating lines E1
	assume inLine(t,e0);
	assume ~used(n);
	threadEnqNode(t,n):= true;
	used(n):= true;
	reach(n,null):=true;
	inLine(t,e0):= false;
	inLine (t,e1):= true
}
action e1_action (t:thread)= { #simulating line E3
	assume inLine(t,e1);
	threadLast(t,M):=false; 	#set to false for all nodes (edit: i dont think this is needed)
	threadLast(t,tail):=true;

	inLine(t,e1):= false;
	inLine (t,e2):= true
}
action e2_action (t:thread,tLast:node)= { #simulating line E4
	assume inLine(t,e2);
	assume (threadEnqLast(t,tLast);
	threadEnqNext(t,M):=false;	#set to false for all nodes

	assert some y. reach(tLast,y);#sanity check
	next:=*;
	assume reach(tLast,x) & (reach(N,x) -> reach(tLast,N));
	threadEnqNext(t,x):=true;

	inLine(t,e2):= false;
	inLine (t,e3):= true
}






action e3_action (t:thread)= { #simulating line E7 //if the condition holds go to next line . otherwise go to loop start
	assume inLine(t,e3);
	if some n:node. threadTail(t,n) {
		if some m:node. tail(m){
			if n=m{
				inLine(t,e3):= false;
				inLine (t,e4):= true
			}else{
				inLine(t,e3):= false;
				inLine (t,e1):= true
			}
		}
	}
}
action e4_action (t:thread)= { #simulating line E8 //if the condition holds go to next line . otherwise go to loop start
	assume inLine(t,e4);
	if some n:node. threadEnqNext(t,n){#next.ptr != NULL
		# Try to swing Tail to the next node  CAS(&Q->Tail, tail, <next.ptr, tail.count+1>)
		if some nn:node. tail(nn){
			if some m:node. threadTail(t,m){
				assert true
				# should call CAS --- TODO line E13
			}
		};
		inLine(t,e4):= false;
		inLine (t,e1):= true
	}else{
		# should call CAS --- TODO line E9
		# if true exit loop
		inLine(t,e4):= false;
		inLine (t,e5):= true
	}
}
action e5_action (t:thread)= { #simulating line E17
	assume inLine(t,e5);
	#should call CAS line E17 TODO
	#free thread
	inLine(t,e5):= false;
	inLine (t,l0):= true
}

action d0_action (t:thread)= { #simulating lines D1-D4 in the code
	assume inLine(t,d0);
	inLine(t,d0):= false;
	inLine (t,d1):= true
}
action d1_action (t:thread)= { #get local head
	assume inLine(t,d1);
	threadDeqHead(t,M):=false; 	#set to false for all nodes
	if some n:node. head(n){
		threadDeqHead(t,n):=true
	};
	inLine(t,d1):= false;
	inLine (t,d2):= true
}
action d2_action (t:thread)= { #get local tail
	assume inLine(t,d2);
	threadDeqTail(t,M):=false; 	#set to false for all nodes
	if some n:node. tail(n){
		threadDeqTail(t,n):=true
	};
	inLine(t,d2):= false;
	inLine (t,d3):= true
}
action d3_action (t:thread) = {
	assume inLine(t,d3);
	threadDeqNext(t,M):=false;	#set to false for all nodes
	if some n:node. threadDeqHead(t,n){
		if some m:node. reach(n,m) & ~reach(m,n) & ((reach(n,A)&A~=n) -> reach(m,A)){
			threadDeqNext(t,M):=true	#"next" variable set . if we did not get here then its "null"
		}
	};
	inLine(t,d3):= false;
	inLine (t,d4):= true
}
action d4_action (t:thread) = {#if head == real head continue to d5 else return to d0
	assume inLine(t,d4);
	if some n:node. threadDeqHead(t,n){
		if some m:node. head(m){
			if n=m{
				inLine(t,d4):= false;
				inLine (t,d5):= true
			}else{
				inLine(t,d4):= false;
				inLine (t,d0):= true
			}
		}
	}
}

action test = {
	assert (threadEnqNode (T,N1) & threadEnqNode (T,N2)) -> N1=N2
}

export l0_action
export e0_action
export test

conjecture (threadEnqNode (T,N1) & threadEnqNode (T,N2)) -> N1=N2
conjecture (inLine (T,L) & (L=l0 | L=e0 | L=d0) ) -> ~threadEnqNode(T,N)
conjecture (inLine (T,L1) & inLine (T,L2)) -> L1=L2
conjecture head(N1) & head(N2) -> N1=N2
