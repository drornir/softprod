#lang ivy1.5
# ivy ui=cti conQueue.ivy
# no longer based on this implementation: https://www.cs.rochester.edu/research/synchronization/pseudocode/queues.html

type node
type state
type thread
type line

relation reach (N1:node, N2:node)# if N2 is reachable from N1
relation nondet
relation inLine (T:thread, L:line) # each thread currently in l0 or some line in the dequeue or enqueue
relation used (N:node) #in order to simulate 'new' node being created

#enq vars
relation threadEnqLast (T:thread,N:node)# local variable of last in thread t
relation threadEnqNode(T:thread, N:node) # the node thread T is trying to enqueue
relation threadEnqNext(T:thread, N:node) # the node which is "next" in line 4 in enqueue
#deq vars
relation threadDeqHead(T:thread, N:node)#the head in deq
relation threadDeqLast(T:thread, N:node)#the tail in deq
relation threadDeqNext(T:thread, N:node)#next
relation threadDeqReturnNode(T:thread, N:node)#rv

relation head(N:node)
relation tail(N:node)


individual l0:line #starting line

individual e0:line # first line in enqeue
individual e1:line # first line in enqeue loop
individual e2:line # set "next"
individual e3:line # first compare
individual e4:line # second compare and CAS if needed
individual e5:line # last line in enqeue
individual e6:line
individual e7:line

individual finishedLine:line

individual d0:line #first line in dequeue
individual d1:line #first line in dequeue
individual d2:line #first line in dequeue
individual d3:line #first line in dequeue
individual d4:line #first line in dequeue
individual d5:line #first line in dequeue
individual dReturn:line #first line in dequeue

individual initNode:node
individual nullNode:node

axiom initNode ~=nullNode

#automatically generated axioms
axiom l0~=e0
axiom l0~=e1
axiom l0~=e2
axiom l0~=e3
axiom l0~=e4
axiom l0~=e5
axiom l0~=e6
axiom l0~=e7
axiom l0~=d0
axiom l0~=d1
axiom l0~=d2
axiom l0~=d3
axiom l0~=d4
axiom l0~=d5
axiom l0~=finishedLine
axiom l0~=dReturn
axiom e0~=e1
axiom e0~=e2
axiom e0~=e3
axiom e0~=e4
axiom e0~=e5
axiom e0~=e6
axiom e0~=e7
axiom e0~=d0
axiom e0~=d1
axiom e0~=d2
axiom e0~=d3
axiom e0~=d4
axiom e0~=d5
axiom e0~=finishedLine
axiom e0~=dReturn
axiom e1~=e2
axiom e1~=e3
axiom e1~=e4
axiom e1~=e5
axiom e1~=e6
axiom e1~=e7
axiom e1~=d0
axiom e1~=d1
axiom e1~=d2
axiom e1~=d3
axiom e1~=d4
axiom e1~=d5
axiom e1~=finishedLine
axiom e1~=dReturn
axiom e2~=e3
axiom e2~=e4
axiom e2~=e5
axiom e2~=e6
axiom e2~=e7
axiom e2~=d0
axiom e2~=d1
axiom e2~=d2
axiom e2~=d3
axiom e2~=d4
axiom e2~=d5
axiom e2~=finishedLine
axiom e2~=dReturn
axiom e3~=e4
axiom e3~=e5
axiom e3~=e6
axiom e3~=e7
axiom e3~=d0
axiom e3~=d1
axiom e3~=d2
axiom e3~=d3
axiom e3~=d4
axiom e3~=d5
axiom e3~=finishedLine
axiom e3~=dReturn
axiom e4~=e5
axiom e4~=e6
axiom e4~=e7
axiom e4~=d0
axiom e4~=d1
axiom e4~=d2
axiom e4~=d3
axiom e4~=d4
axiom e4~=d5
axiom e4~=finishedLine
axiom e4~=dReturn
axiom e5~=e6
axiom e5~=e7
axiom e5~=d0
axiom e5~=d1
axiom e5~=d2
axiom e5~=d3
axiom e5~=d4
axiom e5~=d5
axiom e5~=finishedLine
axiom e5~=dReturn
axiom e6~=e7
axiom e6~=d0
axiom e6~=d1
axiom e6~=d2
axiom e6~=d3
axiom e6~=d4
axiom e6~=d5
axiom e6~=finishedLine
axiom e6~=dReturn
axiom e7~=d0
axiom e7~=d1
axiom e7~=d2
axiom e7~=d3
axiom e7~=d4
axiom e7~=d5
axiom e7~=finishedLine
axiom e7~=dReturn
axiom d0~=d1
axiom d0~=d2
axiom d0~=d3
axiom d0~=d4
axiom d0~=d5
axiom d0~=finishedLine
axiom d0~=dReturn
axiom d1~=d2
axiom d1~=d3
axiom d1~=d4
axiom d1~=d5
axiom d1~=finishedLine
axiom d1~=dReturn
axiom d2~=d3
axiom d2~=d4
axiom d2~=d5
axiom d2~=finishedLine
axiom d2~=dReturn
axiom d3~=d4
axiom d3~=d5
axiom d3~=finishedLine
axiom d3~=dReturn
axiom d4~=d5
axiom d4~=finishedLine
axiom d4~=dReturn
axiom d5~=finishedLine
axiom d5~=dReturn
axiom finishedLine~=dReturn





init inLine(T,l0) & (inLine (T,L) -> L=l0)
init head(N) -> N=initNode
init tail(N) -> N=initNode
init used(initNode) & used(nullNode)
init ~threadEnqNode(T,N)
init ~threadEnqLast(T,N)
init ~threadEnqNext(T,N)
init reach(N,nullNode)


action l0_action(t:thread) = { #decide on an action (enqueue or dequeue)
	assume inLine (t,l0);
	inLine(t,l0) := false;
	nondet :=*;
	if nondet {
		inLine(t,d0) := true
	}
	else {
		inLine (t,e0) := true
	}

}

action e0_action (t:thread,n:node)= { #simulating lines E1
	assume inLine(t,e0);
	assume ~used(n);
	assume (reach(X,n) | reach (n,X)) -> n=X;
	inLine(t,e0):= false;

	threadEnqNode(t,n):= true;
	used(n):= true;
	reach(n,nullNode):=true;
	inLine (t,e1):= true
}

action e1_action (t:thread,globalTail:node)= { #simulating line E3
	assume inLine(t,e1);
	assume tail(globalTail);
	inLine(t,e1):= false;

	threadEnqLast(t,M):=false; 	#set to false for all nodes (edit: i dont think this is needed)

	threadEnqLast(t,globalTail):=true;

	inLine (t,e2):= true
}

action e2_action (t:thread,tLast:node,lastNext:node)= { #simulating line E4
	assume inLine(t,e2);
	assume threadEnqLast(t,tLast);
	assume reach(tLast,lastNext) & (reach(N,lastNext) -> reach(tLast,N));
	inLine(t,e2):= false;

	threadEnqNext(t,M):=false;	#set to false for all nodes

	threadEnqNext(t,lastNext):=true;

	inLine (t,e3):= true
}

action e3_action (t:thread,tLast:node,globalTail:node)= { #simulating line E5 //if the condition holds go to next line . otherwise go to loop start
	assume inLine(t,e3);
	assume threadEnqLast(t,tLast);
	assume tail(globalTail);
	inLine(t,e3):= false;

	if globalTail=tLast {
		inLine (t,e4) := true
	} else {
		inLine (t,e1) := true
	}
}

action e4_action (t:thread,tLast:node)= { #simulating line E7
	assume inLine(t,e4);
	assume threadEnqLast(t,tLast);
	inLine(t,e4):= false;

	if tLast = nullNode {
		inLine(t,e5):= true
	}
	else {
		inLine(t,e6):= true
	}

}
action e5_action (t:thread,last:node,lastNext:node,newNode:node)= { #simulating line E8
	assume inLine(t,e5);
	assume threadEnqNode(t,newNode);
	assume threadEnqLast(t,last);
	assume reach(last,lastNext) & (reach(X,lastNext) -> reach(X,last));
	inLine(t,e5):=false;

	# cas(lastNext,nullNode,newNode)
	if lastNext = nullNode {
		reach(last, lastNext) := false;
		reach(last, newNode) := true;
		inLine(t,e7):=true #goto line E14
	}
	else {
		inLine(t,e6):=true #goto line E11
	}
}

action e6_action (t:thread, globalTail:node, last:node, next:node) = { #line E11
	assume inLine(t,e6);
	assume tail(globalTail);
	assume threadEnqLast(t,last);
	assume threadEnqNext(t,next);
	inLine(t,e6):=false;

	if globalTail = last {
		tail(globalTail) := false;
		tail(next) := true
	};

	inLine(t,e7):=true #goto line E14
}

action e7_action (t:thread, globalTail:node, last:node, newNode:node) = { #line 14
	assume inLine(t,e7);
	assume tail(globalTail);
	assume threadEnqLast(t,last);
	assume threadEnqNode(t,newNode);
	inLine(t,e7):=false;

	# cas(globalTail,last,newNode)
	if globalTail = last {
		tail(globalTail) := false;
		tail(newNode) := true
	};

	inLine(t,finishedLine):=true
}

###################### DEQUEUE ########################

action d0_action (t:thread)= { # D2 get local head
	assume inLine(t,d0);
	inLine(t,d0) := false;

	threadDeqHead(t,M) := false; 	#set to false for all nodes
	if some n:node. head(n){
		threadDeqHead(t,n) := true
	};
	inLine (t,d1) := true
}

action d1_action (t:thread)= { # D3 get local tail
	assume inLine(t,d1);
	inLine(t,d1) := false;

	threadDeqLast(t,M) := false; 	#set to false for all nodes
	if some n:node. tail(n){
		threadDeqLast(t,n) := true
	};
	inLine (t,d2) := true
}


# if the queue is empty, the linearization point is at D4, but we KNOW it was a
# linearization point only at D7. However 'first', 'last' and 'next' of D5-6 can
# not asynchronously change, because they are local variables of the thread.
# Therefore, we can implement D4-6 in a single action without harming correctness.
action d2_action (t:thread, tFirst:node, tLast:node, firstNext:node) = { # D4-6 get first->next and check emptiness
	assume inLine(t,d2);
	assume tail(globalTail);
	assume threadDeqHead(t,tFirst);
	assume threadDeqLast(t,tLast);
	assume reach(tFirst,firstNext) & (reach(N,firstNext) -> reach(tFirst,N));
	inLine (t,d2) := false;

	threadDeqNext(t,M) := false;	#set to false for all nodes
	# D4
	threadDeqNext(t,firstNext) := true;
	# D5-6
	if tFirst = tLast {
		if firstNext = nullNode {
			# D7
			# linearization point EMPTY
			threadDeqReturnNode(t, nullNode) := true;
			inLine (t,dReturn) := true # TODO build "return mechanism" and then fix here
		} else {
			inLine(t,d3) := true # cas
		}
	} else {
		inLine (t,d4):= true
	}
}

action d3_action (t:thread, tLast:node, firstNext:node, globalTail:node) = {# D9
 	assume inLine(t,d3);
	assume threadDeqLast(t,tLast);
	assume threadDeqNext(t,firstNext);
	assume tail(globalTail);
	inLine(t,d3):=false;

	# D9 CAS(&tail, last, next);
	if globalTail = tLast {
		tail(globalTail) := false;
		tail(firstNext) := true
	};
	inLine(t,d0):=true # loop start
}

action d4_action (t:thread,tFirst:node,globalHead:node,firstNext:node) = {#D11
	assume inLine(t,d4);
	inLine(t,d4):=false;
 	assume threadDeqHead(t,tFirst);
	threadDeqReturnNode(t,tFirst):=true;
	inLine(t,d5):=true
}

action d5_action (t:thread,tFirst:node,globalHead:node,firstNext:node) = {#D12
	assume inLine(t,d5);
	assume head(globalHead);
	assume threadDeqHead(t,tFirst);
	assume reach(tFirst,firstNext) & (reach(N,firstNext) -> reach(tFirst,N));
	inLine(t,d5):=false;

	if globalHead = tFirst{
		head(globalHead):=false;
		head(firstNext):=true;
		inLine (t,dReturn) := true # TODO build "return mechanism" and then fix here
	}else{
		inLine(t,d0):=true # goto loop start
	}
}

action dReturn_action(t:thread,rv:node) returns(returnNode:node) = {
	assume inLine(t,dReturn);
	assume threadDeqReturnNode(t, rv);
	inLine(t,dReturn):=false;

	inLine(t,l0):=true;
	returnNode :=rv
}

action test = {
	assert (threadEnqNode (T,N1) & threadEnqNode (T,N2)) -> N1=N2
}

export l0_action
export e0_action
export e1_action
export e2_action
export e3_action
export e4_action
export e5_action
#export e6_action
#export e7_action
export test

conjecture reach(X,X)
conjecture (reach(X,Y) & reach(Y,Z)) -> reach(X,Z)
conjecture reach(X,Y) & reach(Y,X) -> X = Y
conjecture reach(X,Y) & reach(X,Z) -> reach(Y,Z) | reach(Z,Y)

conjecture (threadEnqNode (T,N1) & threadEnqNode (T,N2)) -> N1=N2
conjecture (inLine (T,L) & (L=l0 | L=e0 | L=d0) ) -> ~threadEnqNode(T,N)
conjecture (inLine (T,L1) & inLine (T,L2)) -> L1=L2
conjecture head(N1) & head(N2) -> N1=N2

conjecture (threadEnqNext (T,N1) & threadEnqNext (T,N2)) -> N1=N2

conjecture reach(N,nullNode)

conjecture head(X) -> used(X)
conjecture tail(X) -> used(X)
conjecture head(X) & reach (X,Y) -> used(Y)
conjecture (head(X) & tail (Y)) -> reach (X,Y)
conjecture (head(X) & head(Y)) -> X=Y
conjecture (tail(X) & tail(Y)) -> X=Y

conjecture threadEnqNode(T,X) -> (reach(X,Y) -> X=Y)
